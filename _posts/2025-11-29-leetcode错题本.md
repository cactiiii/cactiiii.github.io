
## 1081 用单调栈 + 条件过滤解题，一时半会想不出来
* https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/solutions/308194/c-on-identical-to-316-by-votrubac-kpte/

## 单调栈解决不了的问题，最长递增子序列，思路比较清奇：
* https://leetcode.cn/problems/longest-increasing-subsequence/solutions/147667/zui-chang-shang-sheng-zi-xu-lie-by-leetcode-soluti/

## 1124 又是单调栈。单调栈一般情况下入栈是需要pop的，但这道题对应的入栈不是pop，而是丢弃当前item。两者其实是等价的，只是遍历顺序不一样导致入栈操作差异。
* https://leetcode.com/problems/longest-well-performing-interval/description/

## c++库函数调用
* string类
    * find、find_first_of 返回的是size_t类型，传入的pos参数也是size_t类型，\n位置的话是等于string::npos
    * begin()、end() 返回的类型是iterator，但是iterator只用来遍历
    * 例如要用substr()的话，传入的参数都是size_t类型
    * to_string() ：中间有下划线！
* map类
    * 两种遍历方式不一样：
        * begin()、end()方式用的是iterator，是指针(it->first，it->second），可以用值传递（开销小）
        * for (auto &pair: map) 方式pair变量直接就是内部的pair，需要用引用传递，避免新建类对象的开销

## 456 又是单调栈
* 题目是寻找132的pattern
* 需要从右往左遍历i，同时用单调栈维护j的候选，同时记录k的max
* 这道题暂时想不出可以总结的规律来

## 1238 考察格雷码，相邻两个数字之间的二进制表示，只差一位
* 公式：g = b ^ (b >> 1)

## 239 滑动窗口最大值，又是单调栈
* https://leetcode.com/problems/sliding-window-maximum/description/
